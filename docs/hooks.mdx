---
title: Hooks
description: The key to unlocking the power of flecks.
---

Hooks are how everything happens in flecks. There are many hooks and the hooks provided by flecks
are documented at the [hooks reference page](./flecks/hooks).

## Implementing (your and other) hooks

To implement hooks (and turn your plain ol' boring JS modules into beautiful interesting flecks),
you only have to export a `hooks` object:

```javascript
export const hooks = {
  '@flecks/core.starting': () => {
    console.log('hello, gorgeous');
  },
};
```

## Invoking your hooks

Hooks may be invoked using different invocation methods which may affect the order of invocation
as well as the final result.

All methods accept an arbitrary number of arguments after the specified arguments.

:::info[Catch you on the flip]

All methods pass the `flecks` instance as the last argument. You never have to include it.

:::

<style>{`
h3 > code:before {
  content: 'flecks.';
}
#invoke > code:after,
#invokeasync > code:after
{
  content: '(hook, ...args)';
}
#invokeflat > code:after {
  content: '(hook, ...args)';
}
#invoke,
#invokecomposed,
#invokemerge,
#invokemergeunique,
#invokereduce,
#invokesequential
{
  margin-bottom: calc( var(--ifm-heading-vertical-rhythm-bottom) * var(--ifm-leading) / 2 )
}
#invokeasync,
#invokecomposedasync,
#invokemergeasync,
#invokemergeuniqueasync,
#invokereduceasync,
#invokesequentialasync
{
  margin-top: 0;
}
#invokecomposed > code:after,
#invokecomposedasync > code:after
{
  content: '(hook, initial, ...args)';
}
#invokefleck > code:after {
  content: '(hook, fleck, ...args)';
}
#invokemerge > code:after,
#invokemergeasync > code:after,
#invokemergeunique > code:after,
#invokemergeuniqueasync > code:after
{
  content: '(hook, ...args)';
}
#invokereduce > code:after,
#invokereduceasync > code:after
{
  content: '(hook, reducer, initial, ...args)';
}
#invokesequential > code:after,
#invokesequentialasync > code:after
{
  content: '(hook, ...args)';
}
#invokemiddleware > code:after
{
  content: '(hook, ...args)';
}
code:before, code:after {
  opacity: 0.5;
}
`}</style>

### `invoke`
### `invokeAsync`

Invokes all hook implementations and returns the results keyed by the implementing flecks' paths.

#### `hook: string`

The hook to invoke.

### `invokeFleck`

Invoke a single fleck's hook implementation and return the result.

#### `hook: string`

The hook to invoke.

#### `fleck: string`

The fleck whose hook to invoke.

### `invokeFlat`

Invokes all hook implementations and returns the results as an array.

#### `hook: string`

The hook to invoke.

:::tip[Just a spoonful of sugar]

The following test would pass:

```js
expect(flecks.invokeFlat('some-hook'))
  .to.deep.equal(Object.values(flecks.invoke('some-hook')));
```

:::

### `invokeComposed`
### `invokeComposedAsync`

See: [function composition](https://www.educative.io/edpresso/function-composition-in-javascript).

`initial` is passed to the first implementation, which returns a result which is passed to the
second implementation, which returns a result which is passed to the third implementation, etc.

#### `hook: string`

The hook to invoke.

#### `initial: any`

The initial value.

Composed hooks are [orderable](./ordering).

### `invokeMerge`
### `invokeMergeAsync`

Invokes all hook implementations and returns the result of merging all implementations' returned objects together.

#### `hook: string`

The hook to invoke.

### `invokeMergeUnique`
### `invokeMergeUniqueAsync`

Specialization of `invokeMerge` that will throw an error if any keys overlap.

#### `hook: string`

The hook to invoke.

### `invokeReduce`
### `invokeReduceAsync`

See: [Array.prototype.reduce()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce)

Invokes hook implementations one at a time, their results being passed to the reducer as `currentValue`. Returns the final reduction.

#### `hook: string`

The hook to invoke.

#### `reduce: function`

The reducer function.

#### `initial: any`

The initial value.

### `invokeSequential`
### `invokeSequentialAsync`

Invokes all hook implementations, one after another. In the async variant, each implementation's result is `await`ed before invoking the next implementation.

#### `hook: string`

The hook to invoke.

Sequential hooks are [orderable](./ordering.mdx).

### `makeMiddleware` {#invokemiddleware}

Hooks may be implemented in the style of Express middleware.

Each implementation will be expected to accept 0 or more arguments followed by a `next` function
which the implementation invokes when passing execution on to the next implementation.

Usage with express would look something like:

```js
app.use(flecks.makeMiddleware('@my/fleck.hook'));
```

For more information, see: http://expressjs.com/en/guide/using-middleware.html

## Documenting your hooks

You should document the hooks you define for the benefit of others (and future you)! You may do so
in `build/flecks.hooks.js`. If you define a hook called `@my/fleck.alarm`, you could write:

```js title="build/flecks.hooks.js"
export const hooks = {
  /**
   * Ring an alarm.
   *
   * @param {number} ding The dinger.
   * @param {string} dong The donger.
   *
   * @invoke Async
   */
  '@my/fleck.alarm': (ding, dong) => {
    // Here's some example usage.
  },
}
```

This is how the [generated hooks page](./flecks/hooks) gathers data to generate the page. You can
even [take advantage of this for your project](./documentation)!
