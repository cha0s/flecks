---
title: Building your application
description: How your application is built.
---

flecks takes a build manifest such as:

```
'@flecks/build': {}
'@flecks/core': {}
'@flecks/server': {}
'@aliased/fleck:./packages/aliased-fleck': {}
```

and determines both the **roots** and **paths** that compose the application, and whether they
require compilation.

## Roots

A root is the package root of a fleck. A package root is defined as a directory with a
`package.json` file.

Multiple fleck paths may share the same root.

<details>
<summary>Sneaky little fleckses</summary>

`@flecks/react`'s root contains 7 flecks!

- `@flecks/react`
- `@flecks/react/client`
- `@flecks/react/router`
- `@flecks/react/router/client`
- `@flecks/react/router/server`
- `@flecks/react/server`
- `@flecks/react/tabs`

</details>

A root prefers to discover flecks within the `src` directory, but will fallback to discovering
files under the root if that fails.

### Bootstrap

flecks runs a bootstrap phase during which all **roots** are checked for the existence of a
`build/flecks.bootstrap.js` script. If one exists, it is loaded as a fleck. The main difference
is **the bootstrap script is executed by Node.JS as-is** and is not subject to any compilation or
preprocessing.

In addition to exporting `hooks`, a bootstrap script may also export:

### Dependencies

Dependent flecks will automatically be added to the build manifest.

```js
exports.dependencies = ['@some/fleck'];
```

:::tip[Fostering dependency]

If you run `flecks add @some/fleck` in your fleck root, `@some/fleck` will be added to your
`package.json` and your `exports.dependencies` will be automatically updated to include
`@some/fleck`.

:::

### Stubs

Some code isn't careful when it comes to things like accessing `window`. flecks can stub out
problem modules on any platform:

```js
exports.stubs = {
  server: ['@pixi'],
};
```

This is effectively the Node.JS `require()` version of
[Webpack's `{'alias': false}` functionality](https://webpack.js.org/configuration/resolve/#resolvealias).

## Compiling flecks

A fleck will not always be compiled. Distributed flecks in production (e.g. one you install from
`npm`) have already gone through a compilation step and will load very fast.

There are some conditions that, when matched, will result in a fleck being compiled.

### Paths and aliases

Paths are the package names of flecks. From our example above, `@aliased/fleck` is a
path. `./packages/aliased-fleck` is an **alias**.

:::info[Compilation condition]

The root path of an aliased fleck is **compiled**.

:::

<details>
<summary>Pitfalls with aliasing</summary>

:::warning[Aliased modules spaghetti]

When an aliased fleck is compiled, its own `node_modules` directory is added to the module search
paths for the application. This makes it **very easy** to get started writing a modular fleck.

There can easily come a point where aliased flecks in an application may have very esoteric
relationship between their `node_modules` directories, including but not limited to duplicate
versions of libraries being included in a compilation.

flecks makes very little effort to solve this problem as it is considered out of scope.

:::

:::warning[Unlikely alias]

You probably shouldn't do things like name an alias the same thing as a package that actually
exists in your `node_modules` directory. This is mitigated if you use the default monorepo
structure (unless your application name is identical to a monorepo organization that already
exists on `npm`: **don't do that**).

:::

All that being said, **aliasing exists** and it can take you pretty far!

If you'd like to help define better behavior for these edge cases you could always
[submit a pull request](https://github.com/cha0s/flecks/compare). :smile:

</details>


### Symlinks

:::info[Compilation condition]

If a root path is a symlinked path, the root path is **compiled**.

:::warning[Land of linkin']

Remember when you're linking a fleck to **link the output `dist` directory** and not the root path
of the fleck.

When building a fleck, [`package.json` is processed](./building-your-fleck#processing-packagejson)
and that processed output should ideally be the `package.json` that your package manager sees.

Don't worry: if the linked path ends with `/dist`, the parent directory will be used as the root
path!

:::

:::tip[Link 'em up]

When you are developing anything Sufficiently Complex:tm:, **best practice is to symlink your
fleck** so that your package manager can do its job and manage your dependency tree.

:::

Next, let's add and interact with some of the flecks shipped by default.
